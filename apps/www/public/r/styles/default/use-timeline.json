{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-timeline",
  "type": "registry:hook",
  "dependencies": [
    "lodash.clamp",
    "zustand"
  ],
  "registryDependencies": [
    "https://limeplay.winoffrg.dev/r/styles/default/use-player-root-store.json",
    "https://limeplay.winoffrg.dev/r/styles/default/utils.json",
    "https://limeplay.winoffrg.dev/r/styles/default/media-provider.json"
  ],
  "files": [
    {
      "path": "registry/default/hooks/use-timeline.ts",
      "content": "import React, { useCallback } from \"react\"\nimport clamp from \"lodash.clamp\"\nimport type { StateCreator } from \"zustand\"\n\nimport type { PlayerRootStore } from \"@/registry/default/hooks/use-player-root-store\"\nimport { noop, off, on, toFixedNumber } from \"@/registry/default/lib/utils\"\nimport {\n  useGetStore,\n  useMediaStore,\n} from \"@/registry/default/ui/media-provider\"\n\nexport interface TimelineStore {\n  duration: number\n  currentTime: number\n  progress: number\n  hoveringTime: number\n  isHovering: boolean\n  buffered: shaka.extern.BufferedRange[]\n  isLive: boolean\n}\n\nexport const createTimelineStore: StateCreator<\n  TimelineStore & PlayerRootStore,\n  [],\n  [],\n  TimelineStore\n> = () => ({\n  duration: 0,\n  currentTime: 0,\n  progress: 0,\n  hoveringTime: 0,\n  isHovering: false,\n  buffered: [],\n  isLive: false,\n})\n\nexport function useTimelineStates() {\n  const store = useGetStore()\n  const player = useMediaStore((s) => s.player)\n  const mediaRef = useMediaStore((state) => state.mediaRef)\n\n  const onTimeUpdate = () => {\n    if (!mediaRef.current) return\n\n    const { duration, currentTime } = mediaRef.current\n    const progress = toFixedNumber(currentTime / duration, 4)\n\n    store.setState({ currentTime, progress: progress || 0 })\n  }\n\n  const onDurationChange = React.useCallback(() => {\n    if (!mediaRef.current) return\n\n    const { duration } = mediaRef.current\n    if (duration && Number.isFinite(duration)) {\n      store.setState({ duration })\n    }\n  }, [store, mediaRef])\n\n  const onBuffer = React.useCallback(() => {\n    if (!player) return\n\n    const bufferedInfo = player.getBufferedInfo()\n\n    if (player.isBuffering() && bufferedInfo.total.length === 0) {\n      return\n    }\n\n    store.setState({ buffered: bufferedInfo.total })\n  }, [store, player])\n\n  React.useEffect(() => {\n    if (!mediaRef.current || !player) return noop\n\n    const media = mediaRef.current\n\n    if (media.readyState >= 1) {\n      onTimeUpdate()\n      onDurationChange()\n      onBuffer()\n    }\n\n    on(media, \"timeupdate\", onTimeUpdate)\n    on(media, [\"durationchange\", \"loadedmetadata\"], onDurationChange)\n    on(media, \"progress\", onBuffer)\n    on(player, \"trackschanged\", onBuffer)\n\n    return () => {\n      off(media, \"timeupdate\", onTimeUpdate)\n      off(media, [\"durationchange\", \"loadedmetadata\"], onDurationChange)\n      off(media, \"progress\", onBuffer)\n      off(player, \"trackschanged\", onBuffer)\n    }\n  }, [mediaRef, player])\n}\n\nexport function useTimeline() {\n  const store = useGetStore()\n  const mediaRef = useMediaStore((state) => state.mediaRef)\n  const duration = useMediaStore((state) => state.duration)\n\n  const getTimeFromEvent = useCallback(\n    (event: React.PointerEvent) => {\n      const rect = event.currentTarget.getBoundingClientRect()\n      const percentage = (event.clientX - rect.left) / rect.width\n      const clampedPercentage = Math.max(0, Math.min(1, percentage))\n      return duration ? clampedPercentage * duration : 0\n    },\n    [duration]\n  )\n\n  function seek(time: number) {\n    if (!mediaRef.current || !Number.isFinite(duration)) return\n\n    const media = mediaRef.current\n\n    const clampedTime = clamp(time, 0, duration)\n\n    store.setState({\n      progress: clampedTime / duration,\n      currentTime: clampedTime,\n    })\n\n    media.currentTime = time\n  }\n\n  function setHoveringTime(time: number) {\n    const { duration } = store.getState()\n    if (!Number.isFinite(duration)) return\n\n    // store.setState({\n    //   hoveringTime: clamp(time, 0, duration),\n    // })\n    store.setState({\n      hoveringTime: time,\n    })\n  }\n\n  function setIsHovering(isHovering: boolean) {\n    store.setState({ isHovering })\n  }\n\n  return {\n    seek,\n    setHoveringTime,\n    setIsHovering,\n    getTimeFromEvent,\n  }\n}\n",
      "type": "registry:hook"
    }
  ]
}