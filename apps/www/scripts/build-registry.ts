/* eslint-disable @typescript-eslint/no-unused-expressions */

import { exec } from "child_process"
import { promises as fs } from "fs"
import path from "path"
import { rimraf } from "rimraf"
import { type Registry, registryItemSchema } from "shadcn/schema"
import { z } from "zod"

import { registry } from "@/registry/collection/index"

type LogLevel = "debug" | "error" | "info" | "warn"
const LOG_LEVEL: LogLevel = (process.env.LOG_LEVEL ?? "info") as LogLevel

const logLevels: Record<LogLevel, number> = {
  debug: 3,
  error: 0,
  info: 2,
  warn: 1,
}

const shouldLog = (level: LogLevel): boolean => {
  return logLevels[level] <= logLevels[LOG_LEVEL]
}

const logger = {
  debug: (message: string) => {
    shouldLog("debug") && console.debug(message)
  },
  error: (message: string) => {
    console.error(message)
  },
  info: (message: string) => {
    shouldLog("info") && console.log(message)
  },
  warn: (message: string) => {
    shouldLog("warn") && console.warn(message)
  },
}

const STYLE = "default"
const PRO_STYLE = "pro"
const DEPRECATED_ITEMS = ["test"]
const REGISTRY_HOST = process.env.REGISTRY_HOST ?? "http://localhost:3000"
const BASE_URL = `${REGISTRY_HOST}/r`
const PRO_BASE_URL = `${REGISTRY_HOST}/r/pro`

logger.info(`üåê Using registry host: ${REGISTRY_HOST}`)

const PATH_MAPPINGS = [
  {
    pattern: "blocks/",
    targetFn: (path: string) => {
      // Extract the part after "blocks/"
      const match = /blocks\/([^/]+)\/(.+)/.exec(path)
      if (match) {
        const [, blockName, filePath] = match
        return `components/${blockName}/${filePath}`
      }
      return null
    },
  },
  // Add more mappings as needed:
  // { pattern: "hooks/", targetFn: ... },
  // { pattern: "ui/", targetFn: ... },
]

// Create a map of all file paths to their corresponding items
function createFilePathToItemMap(
  items: Registry["items"]
): Map<string, string> {
  const map = new Map<string, string>()
  items.forEach((item) => {
    if (item.files) {
      item.files.forEach((file) => {
        const filePath = typeof file === "string" ? file : file.path
        map.set(filePath, item.name)
      })
    }
  })
  return map
}

// Create a map of all registry items for quick lookup
function createRegistryItemsMap(
  items: Registry["items"]
): Map<string, Registry["items"][number]> {
  const map = new Map()
  items.forEach((item) => {
    if (item.name && !DEPRECATED_ITEMS.includes(item.name)) {
      map.set(item.name, item)
    }
  })
  return map
}

/**
 * Dynamically load pro registry items if available.
 */
// Unified registry items from index
const registryItems = registry.items
const registryItemsMap = createRegistryItemsMap(registryItems)
const filePathToItemMap = createFilePathToItemMap(registryItems)

// Helper to check if item is pro
const isProItem = (item: Registry["items"][number]) => {
  return item.categories?.includes("pro")
}

async function buildCombinedRegistryIndex(
  registries: Array<{ registry: Registry; style: string }>
) {
  logger.info(
    `üóÇÔ∏è Building registry/__index__.tsx with ${registries.length} tier(s)...`
  )

  let index = `/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.

import * as React from "react"

export const Index: Record<string, any> = {`

  for (const { registry, style } of registries) {
    index += `
  "${style}": {`

    for (const item of registry.items) {
      const resolveFiles = item.files?.map(
        (file) => `registry/${style}/${file.path}`
      )
      if (!resolveFiles) {
        continue
      }

      const componentPath = item.files?.[0]?.path
        ? `@/registry/${style}/${item.files[0].path}`
        : ""

      index += `
    "${item.name}": {
      name: "${item.name}",
      description: "${item.description ?? ""}",
      type: "${item.type}",
      registryDependencies: ${JSON.stringify(item.registryDependencies)},
      files: [${item.files?.map((file) => {
        const filePath = `registry/${style}/${
          typeof file === "string" ? file : file.path
        }`
        const resolvedFilePath = path.resolve(filePath)
        return typeof file === "string"
          ? `"${resolvedFilePath}"`
          : `{
        path: "${filePath}",
        type: "${file.type}",
        target: "${file.target ?? ""}"
      }`
      })}],
      component: ${
        componentPath
          ? `React.lazy(async () => {
        const mod = await import("${componentPath}")
        const exportName = Object.keys(mod).find(key => typeof mod[key] === 'function' || typeof mod[key] === 'object') || "${item.name}"
        return { default: mod.default || mod[exportName] }
      })`
          : "null"
      },
      meta: ${JSON.stringify(item.meta)},
    },`
    }

    index += `
  },`
  }

  index += `
}`

  // Create registry directory if it doesn't exist
  const registryDir = path.join(process.cwd(), "registry")
  await fs.mkdir(registryDir, { recursive: true })

  // Write combined index
  rimraf.sync(path.join(registryDir, "__index__.tsx"))
  await fs.writeFile(path.join(registryDir, "__index__.tsx"), index)
}

async function buildRegistryJsonFile(
  registry: Registry,
  style: string,
  fileName = "registry.json"
) {
  logger.info(`üíÖ Building ${fileName}...`)
  // 1. Fix the path for registry items.
  const fixedRegistry = {
    ...registry,
    items: registry.items.map((item) => {
      const files = item.files?.map((file) => {
        return {
          ...file,
          path: `registry/${style}/${file.path}`,
        }
      })

      return {
        ...item,
        files,
      }
    }),
  }

  // 2. Write the content of the registry
  rimraf.sync(path.join(process.cwd(), fileName))
  await fs.writeFile(
    path.join(process.cwd(), fileName),
    JSON.stringify(fixedRegistry, null, 2)
  )
}

// Build free registry
// Helper to create registry object
function createRegistry(
  items: Registry["items"],
  name = "winoffrg/limeplay"
): Registry {
  return {
    homepage: "https://limeplay.winoffrg.dev",
    items: z.array(registryItemSchema).parse(processRegistryItems(items)),
    name,
  }
}

// Fetch and parse shadcn registry into a map keyed by name (no top-level await)
async function getShadcnRegistryMap(): Promise<Map<string, unknown>> {
  try {
    const items = await fetch(
      "https://github.com/shadcn-ui/ui/blob/main/apps/v4/public/r/index.json?raw=true"
    ).then((res) => res.json())
    return parseShadcnRegistryItemsToMap(items as Array<{ name?: string }>)
  } catch {
    return new Map<string, unknown>()
  }
}

async function main() {
  try {
    logger.info("üßê Validating dependencies...")

    const hasProRegistry = await proRegistryExists()

    // Split items based on category
    // Free items: No 'pro' category
    const freeItems = registryItems.filter((item) => !isProItem(item))

    // Pro items: Have 'pro' category
    const proItems = registryItems.filter((item) => isProItem(item))

    // Check if we have pro items defined but missing submodule
    if (proItems.length > 0 && !hasProRegistry) {
      logger.warn(
        "‚ö†Ô∏è Pro items found in registry but Pro submodule missing. Pro build will be skipped."
      )
    }

    // Prepare Free Registry items (include index metadata)
    const freeRegistryItemsWithIndex = [
      {
        cssVars: {},
        dependencies: [
          "tw-animate-css",
          "class-variance-authority",
          "lucide-react",
        ],
        files: [],
        name: "index",
        registryDependencies: ["utils"],
        type: "registry:style" as const,
      },
      ...freeItems,
    ]

    // Build free registry
    const freeRegistry = createRegistry(freeRegistryItemsWithIndex)

    // Validate dependencies for free registry (only checking against free items and shadcn)
    // We pass the global registryItemsMap but validateDependencies logic might need adjustment if it expects map to only contain valid items.
    // Actually, validateDependencies checks undefined dependencies.
    // If a free item depends on a pro item (which is in registryItemsMap), it is technically found.
    // But we should ban free -> pro dependency.
    // For now we'll rely on good faith or add a check later.
    await validateDependencies(
      freeRegistry,
      registryItemsMap,
      filePathToItemMap
    )

    // Build free registry JSON
    await buildRegistryJsonFile(freeRegistry, STYLE)

    // Run shadcn build for free components
    // Output to /public/r (root - backwards compat) AND /public/r/free
    await runShadcnBuild("registry.json", "../www/public/r")

    // Copy to /r/free for explicit free path
    const freeOutputDir = path.join(process.cwd(), "public/r/free")
    await fs.mkdir(freeOutputDir, { recursive: true })
    const rootOutputDir = path.join(process.cwd(), "public/r")
    const rootFiles = await fs.readdir(rootOutputDir)
    for (const file of rootFiles) {
      if (file.endsWith(".json") && file !== "registry.json") {
        // Skip directories like 'free' and 'pro'
        const srcPath = path.join(rootOutputDir, file)
        const stat = await fs.stat(srcPath)
        if (stat.isFile()) {
          await fs.copyFile(srcPath, path.join(freeOutputDir, file))
        }
      }
    }
    // Copy registry.json to free dir as well
    await fs.copyFile(
      path.join(rootOutputDir, "registry.json"),
      path.join(freeOutputDir, "registry.json")
    )
    logger.info("‚úÖ Copied free components to /r/free/")

    // Prepare for combined index
    const registriesToIndex = [{ registry: freeRegistry, style: STYLE }]

    // Build pro registry if available and submodule exists
    if (proItems.length > 0 && hasProRegistry) {
      logger.info("üîê Building pro registry...")
      const proRegistry = createRegistry(proItems, "winoffrg/limeplay-pro")

      // Validate dependencies for pro registry
      // It can depend on free items + pro items
      // We use the same map.
      await validateDependencies(
        proRegistry,
        registryItemsMap,
        filePathToItemMap,
        PRO_BASE_URL
      )

      // Add to index list
      registriesToIndex.push({ registry: proRegistry, style: PRO_STYLE })

      // Build pro registry JSON
      await buildRegistryJsonFile(proRegistry, PRO_STYLE, "registry-pro.json")

      // Run shadcn build for pro components
      await runShadcnBuild("registry-pro.json", "../www/public/r/pro")
      logger.info("‚úÖ Pro registry built successfully")
    } else {
      if (proItems.length === 0) {
        logger.info("‚è≠Ô∏è No Pro items defined in registry.")
      } else {
        logger.info("‚è≠Ô∏è Skipping pro registry build (missing submodule)")
      }
    }

    // Build combined index
    await buildCombinedRegistryIndex(registriesToIndex)

    logger.info("üéâ Registry build complete!")
  } catch (error) {
    logger.error(`${error}`)
    process.exit(1)
  }
}

// Convert shadcn registry array into a map keyed by item name.
// We ignore duplicates and only keep the first occurrence.
function parseShadcnRegistryItemsToMap(
  items: Array<{ name?: string }>
): Map<string, unknown> {
  const byName = new Map<string, unknown>()
  if (!Array.isArray(items)) return byName
  for (const item of items) {
    const name = typeof item.name === "string" ? item.name : undefined
    if (!name) continue
    if (!byName.has(name)) {
      byName.set(name, item)
    }
  }
  return byName
}

function processRegistryItems(items: Registry["items"]): Registry["items"] {
  return items
    .filter((item) => !DEPRECATED_ITEMS.includes(item.name))
    .map((item) => {
      if (item.registryDependencies?.length) {
        item.registryDependencies = item.registryDependencies.map((dep) =>
          resolveRegistryDependency(dep)
        )
      }

      if (item.files) {
        item.files = item.files.map((file) => {
          if (typeof file === "string") return file

          if (file.target) return file

          for (const mapping of PATH_MAPPINGS) {
            if (file.path.includes(mapping.pattern)) {
              const target = mapping.targetFn(file.path)
              if (target) {
                logger.debug(`‚úÖ Added target for "${file.path}" ‚Üí "${target}"`)
                return { ...file, target }
              }
            }
          }

          return file
        })
      }

      return item
    })
}

/**
 * Check if the pro registry has actual components.
 */
async function proRegistryExists(): Promise<boolean> {
  try {
    const proPath = path.join(process.cwd(), "registry/pro")
    const stat = await fs.stat(proPath)
    if (!stat.isDirectory()) return false

    const files = await fs.readdir(proPath, { recursive: true })
    return files.some(
      (f) => typeof f === "string" && (f.endsWith(".tsx") || f.endsWith(".ts"))
    )
  } catch {
    return false
  }
}

function resolveRegistryDependency(dependency: string): string {
  if (typeof dependency !== "string" || dependency.startsWith("http")) {
    return dependency
  }

  if (registryItemsMap.has(dependency)) {
    const item = registryItemsMap.get(dependency)
    if (isProItem(item!)) {
      return `${PRO_BASE_URL}/${dependency}.json`
    }
    return `${BASE_URL}/${dependency}.json`
  }

  return dependency
}

async function runShadcnBuild(
  registryFile: string,
  outputDir: string
): Promise<void> {
  logger.info(`üèóÔ∏è Building ${registryFile} to ${outputDir}...`)
  return new Promise((resolve, reject) => {
    const proc = exec(
      `bun x shadcn build ${registryFile} --output ${outputDir}`
    )

    proc.stdout?.on("data", (data) => {
      console.log(data)
    })

    proc.stderr?.on("data", (data) => {
      console.error(data)
    })

    proc.on("exit", (code) => {
      if (code === 0) {
        resolve(undefined)
      } else {
        reject(new Error(`Process exited with code ${code}`))
      }
    })
  })
}

// Check for missing and undefined dependencies
async function validateDependencies(
  registry: Registry,
  itemsMap: Map<string, Registry["items"][number]>,
  filePathMap: Map<string, string>,
  baseUrl: string = BASE_URL
) {
  logger.info("üîç Validating dependencies based on imports...")
  const shadcnRegistryMap = await getShadcnRegistryMap()

  // Regex to find imports from our registry
  const importRegex = /@\/registry\/(default|pro)\/([^"']+)/g

  // Additional regex to catch import * as Namespace patterns
  const namespaceImportRegex =
    /import\s+\*\s+as\s+\w+\s+from\s+["']@\/registry\/(default|pro)\/([^"']+)["']/g

  // Track missing registry entries
  const missingRegistryItems = new Map<string, Set<string>>()

  // Debug registry items
  logger.debug("üìã Registry items: " + Array.from(itemsMap.keys()).join(", "))

  // Check for undefined dependencies first
  for (const item of registry.items) {
    if (!item.registryDependencies?.length) continue

    const undefinedDependencies = []

    for (const dependency of item.registryDependencies) {
      // Skip URL dependencies
      if (typeof dependency !== "string" || dependency.startsWith("http")) {
        continue
      }

      if (dependency.startsWith("@") && dependency.includes("/")) {
        continue
      }

      // Check if dependency exists
      if (!itemsMap.has(dependency) && !shadcnRegistryMap.has(dependency)) {
        undefinedDependencies.push(dependency)
      }
    }

    if (undefinedDependencies.length > 0) {
      logger.error(
        `‚ùå Component "${item.name}" has missing dependencies in registryDependencies:`
      )
      undefinedDependencies.forEach((dep) => {
        logger.error(`   - ${dep} (not found in registry)`)
      })
      logger.error(`   These dependencies need to be defined or removed.`)
    }
  }

  // Check for missing dependencies based on imports
  for (const item of registry.items) {
    if (!item.files) continue

    const declaredDependencies = new Set(
      (item.registryDependencies ?? []).map((dep) => {
        // Extract component name from URL if needed
        if (dep.startsWith("http")) {
          return dep.split("/").pop()?.replace(".json", "") || dep
        }
        return dep
      })
    )
    logger.debug(
      `üì¶ Checking ${item.name} with dependencies: ${
        declaredDependencies.size
          ? Array.from(declaredDependencies).join(", ")
          : "none"
      }`
    )

    const missingDependencies = new Set<string>()

    for (const file of item.files) {
      if (typeof file === "string") continue

      try {
        // Determine the correct style directory based on item category
        const styleDir = isProItem(item) ? PRO_STYLE : STYLE
        const filePath = path.join(
          process.cwd(),
          "registry",
          styleDir,
          file.path
        )
        if (
          !(await fs
            .stat(filePath)
            .then(() => true)
            .catch(() => false))
        ) {
          logger.debug(`‚ö†Ô∏è File not found: ${filePath}`)
          continue
        }

        logger.debug(`üîé Checking file: ${file.path}`)
        const content = await fs.readFile(filePath, "utf8")

        // Process both regular imports and namespace imports
        const regularImports = [...content.matchAll(importRegex)]
        const namespaceImports = [...content.matchAll(namespaceImportRegex)]

        logger.debug(
          `  - Found ${regularImports.length.toString()} regular imports, ${namespaceImports.length.toString()} namespace imports`
        )

        const allMatches = [...regularImports, ...namespaceImports]

        if (allMatches.length === 0) {
          logger.debug(`  - No registry imports found in file`)
        }

        for (const match of allMatches) {
          const importStyle = match[1] // "default" or "pro"
          const importPath = match[2]
          logger.debug(
            `  - Found import: @/registry/${importStyle}/${importPath}`
          )

          const importParts = importPath.split("/")

          // Skip if it's importing from itself
          if (file.path.startsWith(`${importParts[0]}/${importParts[1]}`)) {
            logger.debug(`    - Skipping self-import: ${importPath}`)
            continue
          }

          const importType = importParts[0] // ui, blocks, hooks, etc.
          const importName = importParts[1] // player-hooks, media-provider, etc.
          logger.debug(`    - Import type: ${importType}, name: ${importName}`)

          // Try to find the component by name
          if (itemsMap.has(importName)) {
            logger.debug(`    - Component exists: ${importName}`)
            // Component exists by name - check if it's already a dependency
            const dependencyUrl = `${baseUrl}/${importName}.json`
            if (
              !declaredDependencies.has(importName) &&
              !declaredDependencies.has(dependencyUrl)
            ) {
              logger.debug(`    - Adding missing dependency: ${importName}`)
              missingDependencies.add(importName)
            } else {
              logger.debug(`    - Dependency already declared: ${importName}`)
            }
            continue
          } else {
            logger.debug(`    - No direct component match for: ${importName}`)

            // Track missing registry items
            if (!missingRegistryItems.has(item.name)) {
              missingRegistryItems.set(item.name, new Set())
            }
            missingRegistryItems.get(item.name)?.add(importName)
          }

          // Find the component that provides this file
          const componentPath = `${importParts[0]}/${importParts[1]}`
          const possibleFilePaths = Array.from(filePathMap.keys()).filter((p) =>
            p.startsWith(componentPath)
          )

          logger.debug(
            `    - Looking for components with path: ${componentPath}`
          )
          logger.debug(
            `    - Found ${possibleFilePaths.length.toString()} possible matches`
          )

          if (possibleFilePaths.length > 0) {
            for (const fp of possibleFilePaths) {
              const componentName = filePathMap.get(fp) ?? ""
              logger.debug(
                `      - Matched file: ${fp} ‚Üí component: ${componentName}`
              )

              // Check if this component is already in dependencies
              const dependencyUrl = `${baseUrl}/${componentName}.json`
              if (
                componentName &&
                componentName !== item.name &&
                !declaredDependencies.has(componentName) &&
                !declaredDependencies.has(dependencyUrl)
              ) {
                logger.debug(
                  `      - Adding missing dependency: ${componentName}`
                )
                missingDependencies.add(componentName)
              } else if (componentName) {
                logger.debug(
                  `      - Dependency already declared or self-reference: ${componentName}`
                )
              }
            }
          } else {
            logger.debug(`    - No file path matches found`)
          }
        }
      } catch (error) {
        logger.error(`Error reading file ${file.path}: ${error as string}`)
      }
    }

    if (missingDependencies.size > 0) {
      logger.warn(
        `‚ö†Ô∏è Component "${item.name}" is missing dependencies in registryDependencies:`
      )
      missingDependencies.forEach((dep) => {
        logger.warn(`   - ${dep}`)
      })
      logger.warn(
        `   Add them to the registryDependencies array in the registry definition.`
      )

      // Force log flush by adding a slight delay
      await new Promise((resolve) => setTimeout(resolve, 10))
    } else {
      logger.debug(`‚úÖ No missing dependencies for ${item.name}`)
    }
  }

  // Report missing registry items
  if (missingRegistryItems.size > 0) {
    logger.error(
      "\nüö´ Components are importing from registry items that don't exist:"
    )

    for (const [component, imports] of missingRegistryItems.entries()) {
      logger.error(
        `   - "${component}" imports: ${Array.from(imports).join(", ")}`
      )
    }

    logger.error(
      "   These components should be registered in the appropriate registry file (registry-ui.ts, etc.)\n"
    )

    // Force log flush by adding a slight delay
    await new Promise((resolve) => setTimeout(resolve, 100))
  }
}

main()
  .then(() => {
    process.exit(0)
  })
  .catch((error: unknown) => {
    logger.error(`${error}`)
    process.exit(1)
  })
